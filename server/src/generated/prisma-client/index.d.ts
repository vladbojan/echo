// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  frame: (where?: FrameWhereInput) => Promise<boolean>;
  paragraph: (where?: ParagraphWhereInput) => Promise<boolean>;
  scene: (where?: SceneWhereInput) => Promise<boolean>;
  story: (where?: StoryWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  frame: (where: FrameWhereUniqueInput) => FrameNullablePromise;
  frames: (args?: {
    where?: FrameWhereInput;
    orderBy?: FrameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Frame>;
  framesConnection: (args?: {
    where?: FrameWhereInput;
    orderBy?: FrameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FrameConnectionPromise;
  paragraph: (where: ParagraphWhereUniqueInput) => ParagraphNullablePromise;
  paragraphs: (args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Paragraph>;
  paragraphsConnection: (args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParagraphConnectionPromise;
  scene: (where: SceneWhereUniqueInput) => SceneNullablePromise;
  scenes: (args?: {
    where?: SceneWhereInput;
    orderBy?: SceneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Scene>;
  scenesConnection: (args?: {
    where?: SceneWhereInput;
    orderBy?: SceneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SceneConnectionPromise;
  story: (where: StoryWhereUniqueInput) => StoryNullablePromise;
  stories: (args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Story>;
  storiesConnection: (args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StoryConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createFrame: (data: FrameCreateInput) => FramePromise;
  updateFrame: (args: {
    data: FrameUpdateInput;
    where: FrameWhereUniqueInput;
  }) => FramePromise;
  updateManyFrames: (args: {
    data: FrameUpdateManyMutationInput;
    where?: FrameWhereInput;
  }) => BatchPayloadPromise;
  upsertFrame: (args: {
    where: FrameWhereUniqueInput;
    create: FrameCreateInput;
    update: FrameUpdateInput;
  }) => FramePromise;
  deleteFrame: (where: FrameWhereUniqueInput) => FramePromise;
  deleteManyFrames: (where?: FrameWhereInput) => BatchPayloadPromise;
  createParagraph: (data: ParagraphCreateInput) => ParagraphPromise;
  updateParagraph: (args: {
    data: ParagraphUpdateInput;
    where: ParagraphWhereUniqueInput;
  }) => ParagraphPromise;
  updateManyParagraphs: (args: {
    data: ParagraphUpdateManyMutationInput;
    where?: ParagraphWhereInput;
  }) => BatchPayloadPromise;
  upsertParagraph: (args: {
    where: ParagraphWhereUniqueInput;
    create: ParagraphCreateInput;
    update: ParagraphUpdateInput;
  }) => ParagraphPromise;
  deleteParagraph: (where: ParagraphWhereUniqueInput) => ParagraphPromise;
  deleteManyParagraphs: (where?: ParagraphWhereInput) => BatchPayloadPromise;
  createScene: (data: SceneCreateInput) => ScenePromise;
  updateScene: (args: {
    data: SceneUpdateInput;
    where: SceneWhereUniqueInput;
  }) => ScenePromise;
  updateManyScenes: (args: {
    data: SceneUpdateManyMutationInput;
    where?: SceneWhereInput;
  }) => BatchPayloadPromise;
  upsertScene: (args: {
    where: SceneWhereUniqueInput;
    create: SceneCreateInput;
    update: SceneUpdateInput;
  }) => ScenePromise;
  deleteScene: (where: SceneWhereUniqueInput) => ScenePromise;
  deleteManyScenes: (where?: SceneWhereInput) => BatchPayloadPromise;
  createStory: (data: StoryCreateInput) => StoryPromise;
  updateStory: (args: {
    data: StoryUpdateInput;
    where: StoryWhereUniqueInput;
  }) => StoryPromise;
  updateManyStories: (args: {
    data: StoryUpdateManyMutationInput;
    where?: StoryWhereInput;
  }) => BatchPayloadPromise;
  upsertStory: (args: {
    where: StoryWhereUniqueInput;
    create: StoryCreateInput;
    update: StoryUpdateInput;
  }) => StoryPromise;
  deleteStory: (where: StoryWhereUniqueInput) => StoryPromise;
  deleteManyStories: (where?: StoryWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  frame: (
    where?: FrameSubscriptionWhereInput
  ) => FrameSubscriptionPayloadSubscription;
  paragraph: (
    where?: ParagraphSubscriptionWhereInput
  ) => ParagraphSubscriptionPayloadSubscription;
  scene: (
    where?: SceneSubscriptionWhereInput
  ) => SceneSubscriptionPayloadSubscription;
  story: (
    where?: StorySubscriptionWhereInput
  ) => StorySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ParagraphOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "content_ASC"
  | "content_DESC"
  | "styling_ASC"
  | "styling_DESC"
  | "media_ASC"
  | "media_DESC"
  | "position_ASC"
  | "position_DESC";

export type FrameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "styling_ASC"
  | "styling_DESC"
  | "media_ASC"
  | "media_DESC"
  | "position_ASC"
  | "position_DESC";

export type SceneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "styling_ASC"
  | "styling_DESC"
  | "media_ASC"
  | "media_DESC"
  | "position_ASC"
  | "position_DESC";

export type StoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "styling_ASC"
  | "styling_DESC"
  | "media_ASC"
  | "media_DESC"
  | "position_ASC"
  | "position_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface StoryUpsertWithoutScenesInput {
  update: StoryUpdateWithoutScenesDataInput;
  create: StoryCreateWithoutScenesInput;
}

export type FrameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ParagraphUpdateManyWithoutParentInput {
  create?: Maybe<
    ParagraphCreateWithoutParentInput[] | ParagraphCreateWithoutParentInput
  >;
  delete?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  connect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  set?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  disconnect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  update?: Maybe<
    | ParagraphUpdateWithWhereUniqueWithoutParentInput[]
    | ParagraphUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | ParagraphUpsertWithWhereUniqueWithoutParentInput[]
    | ParagraphUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  updateMany?: Maybe<
    | ParagraphUpdateManyWithWhereNestedInput[]
    | ParagraphUpdateManyWithWhereNestedInput
  >;
}

export interface StoryUpdateInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  scenes?: Maybe<SceneUpdateManyWithoutParentInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutStoriesInput>;
  position?: Maybe<String>;
}

export interface ParagraphUpdateWithWhereUniqueWithoutParentInput {
  where: ParagraphWhereUniqueInput;
  data: ParagraphUpdateWithoutParentDataInput;
}

export interface StoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  scenes_every?: Maybe<SceneWhereInput>;
  scenes_some?: Maybe<SceneWhereInput>;
  scenes_none?: Maybe<SceneWhereInput>;
  author?: Maybe<UserWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<StoryWhereInput[] | StoryWhereInput>;
  OR?: Maybe<StoryWhereInput[] | StoryWhereInput>;
  NOT?: Maybe<StoryWhereInput[] | StoryWhereInput>;
}

export interface ParagraphUpdateWithoutParentDataInput {
  published?: Maybe<Boolean>;
  content?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ParagraphUpsertWithWhereUniqueWithoutParentInput {
  where: ParagraphWhereUniqueInput;
  update: ParagraphUpdateWithoutParentDataInput;
  create: ParagraphCreateWithoutParentInput;
}

export interface SceneSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SceneWhereInput>;
  AND?: Maybe<SceneSubscriptionWhereInput[] | SceneSubscriptionWhereInput>;
  OR?: Maybe<SceneSubscriptionWhereInput[] | SceneSubscriptionWhereInput>;
  NOT?: Maybe<SceneSubscriptionWhereInput[] | SceneSubscriptionWhereInput>;
}

export interface ParagraphScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  OR?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  NOT?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
}

export interface ParagraphSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParagraphWhereInput>;
  AND?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
}

export interface ParagraphUpdateManyWithWhereNestedInput {
  where: ParagraphScalarWhereInput;
  data: ParagraphUpdateManyDataInput;
}

export interface FrameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FrameWhereInput>;
  AND?: Maybe<FrameSubscriptionWhereInput[] | FrameSubscriptionWhereInput>;
  OR?: Maybe<FrameSubscriptionWhereInput[] | FrameSubscriptionWhereInput>;
  NOT?: Maybe<FrameSubscriptionWhereInput[] | FrameSubscriptionWhereInput>;
}

export interface ParagraphUpdateManyDataInput {
  published?: Maybe<Boolean>;
  content?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface StoryUpdateManyDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface SceneUpdateOneRequiredWithoutFramesInput {
  create?: Maybe<SceneCreateWithoutFramesInput>;
  update?: Maybe<SceneUpdateWithoutFramesDataInput>;
  upsert?: Maybe<SceneUpsertWithoutFramesInput>;
  connect?: Maybe<SceneWhereUniqueInput>;
}

export interface StoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  OR?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  NOT?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
}

export interface SceneUpdateWithoutFramesDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent?: Maybe<StoryUpdateOneRequiredWithoutScenesInput>;
  position?: Maybe<String>;
}

export type ParagraphWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StoryUpdateOneRequiredWithoutScenesInput {
  create?: Maybe<StoryCreateWithoutScenesInput>;
  update?: Maybe<StoryUpdateWithoutScenesDataInput>;
  upsert?: Maybe<StoryUpsertWithoutScenesInput>;
  connect?: Maybe<StoryWhereUniqueInput>;
}

export interface StoryUpdateWithWhereUniqueWithoutAuthorInput {
  where: StoryWhereUniqueInput;
  data: StoryUpdateWithoutAuthorDataInput;
}

export interface StoryUpdateWithoutScenesDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutStoriesInput>;
  position?: Maybe<String>;
}

export type SceneWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutStoriesInput {
  create?: Maybe<UserCreateWithoutStoriesInput>;
  update?: Maybe<UserUpdateWithoutStoriesDataInput>;
  upsert?: Maybe<UserUpsertWithoutStoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StoryCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  scenes?: Maybe<SceneCreateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface UserUpdateWithoutStoriesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
}

export type StoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutStoriesInput {
  update: UserUpdateWithoutStoriesDataInput;
  create: UserCreateWithoutStoriesInput;
}

export interface StoryUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface SceneUpdateWithWhereUniqueWithoutParentInput {
  where: SceneWhereUniqueInput;
  data: SceneUpdateWithoutParentDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface SceneUpsertWithoutFramesInput {
  update: SceneUpdateWithoutFramesDataInput;
  create: SceneCreateWithoutFramesInput;
}

export interface SceneScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<SceneScalarWhereInput[] | SceneScalarWhereInput>;
  OR?: Maybe<SceneScalarWhereInput[] | SceneScalarWhereInput>;
  NOT?: Maybe<SceneScalarWhereInput[] | SceneScalarWhereInput>;
}

export interface FrameUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface SceneUpdateWithoutParentDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  frames?: Maybe<FrameUpdateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface SceneUpdateManyWithoutParentInput {
  create?: Maybe<
    SceneCreateWithoutParentInput[] | SceneCreateWithoutParentInput
  >;
  delete?: Maybe<SceneWhereUniqueInput[] | SceneWhereUniqueInput>;
  connect?: Maybe<SceneWhereUniqueInput[] | SceneWhereUniqueInput>;
  set?: Maybe<SceneWhereUniqueInput[] | SceneWhereUniqueInput>;
  disconnect?: Maybe<SceneWhereUniqueInput[] | SceneWhereUniqueInput>;
  update?: Maybe<
    | SceneUpdateWithWhereUniqueWithoutParentInput[]
    | SceneUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | SceneUpsertWithWhereUniqueWithoutParentInput[]
    | SceneUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<SceneScalarWhereInput[] | SceneScalarWhereInput>;
  updateMany?: Maybe<
    SceneUpdateManyWithWhereNestedInput[] | SceneUpdateManyWithWhereNestedInput
  >;
}

export interface FrameCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title: String;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  paragraphs?: Maybe<ParagraphCreateManyWithoutParentInput>;
  parent: SceneCreateOneWithoutFramesInput;
  position?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  stories_every?: Maybe<StoryWhereInput>;
  stories_some?: Maybe<StoryWhereInput>;
  stories_none?: Maybe<StoryWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ParagraphCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  content: String;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface ParagraphCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  content: String;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent: FrameCreateOneWithoutParagraphsInput;
  position?: Maybe<String>;
}

export interface SceneCreateWithoutFramesInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent: StoryCreateOneWithoutScenesInput;
  position?: Maybe<String>;
}

export interface FrameCreateOneWithoutParagraphsInput {
  create?: Maybe<FrameCreateWithoutParagraphsInput>;
  connect?: Maybe<FrameWhereUniqueInput>;
}

export interface StoryCreateWithoutScenesInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  author: UserCreateOneWithoutStoriesInput;
  position?: Maybe<String>;
}

export interface FrameCreateWithoutParagraphsInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title: String;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent: SceneCreateOneWithoutFramesInput;
  position?: Maybe<String>;
}

export interface UserCreateWithoutStoriesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name: String;
}

export interface ParagraphUpdateInput {
  published?: Maybe<Boolean>;
  content?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent?: Maybe<FrameUpdateOneRequiredWithoutParagraphsInput>;
  position?: Maybe<String>;
}

export interface SceneWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  frames_every?: Maybe<FrameWhereInput>;
  frames_some?: Maybe<FrameWhereInput>;
  frames_none?: Maybe<FrameWhereInput>;
  parent?: Maybe<StoryWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<SceneWhereInput[] | SceneWhereInput>;
  OR?: Maybe<SceneWhereInput[] | SceneWhereInput>;
  NOT?: Maybe<SceneWhereInput[] | SceneWhereInput>;
}

export interface FrameUpdateOneRequiredWithoutParagraphsInput {
  create?: Maybe<FrameCreateWithoutParagraphsInput>;
  update?: Maybe<FrameUpdateWithoutParagraphsDataInput>;
  upsert?: Maybe<FrameUpsertWithoutParagraphsInput>;
  connect?: Maybe<FrameWhereUniqueInput>;
}

export interface FrameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  paragraphs_every?: Maybe<ParagraphWhereInput>;
  paragraphs_some?: Maybe<ParagraphWhereInput>;
  paragraphs_none?: Maybe<ParagraphWhereInput>;
  parent?: Maybe<SceneWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<FrameWhereInput[] | FrameWhereInput>;
  OR?: Maybe<FrameWhereInput[] | FrameWhereInput>;
  NOT?: Maybe<FrameWhereInput[] | FrameWhereInput>;
}

export interface FrameUpdateWithoutParagraphsDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  parent?: Maybe<SceneUpdateOneRequiredWithoutFramesInput>;
  position?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
}

export interface FrameUpsertWithoutParagraphsInput {
  update: FrameUpdateWithoutParagraphsDataInput;
  create: FrameCreateWithoutParagraphsInput;
}

export interface StoryUpsertWithWhereUniqueWithoutAuthorInput {
  where: StoryWhereUniqueInput;
  update: StoryUpdateWithoutAuthorDataInput;
  create: StoryCreateWithoutAuthorInput;
}

export interface ParagraphUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  content?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface StoryUpdateManyWithoutAuthorInput {
  create?: Maybe<
    StoryCreateWithoutAuthorInput[] | StoryCreateWithoutAuthorInput
  >;
  delete?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  set?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  disconnect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  update?: Maybe<
    | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    | StoryUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    | StoryUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  updateMany?: Maybe<
    StoryUpdateManyWithWhereNestedInput[] | StoryUpdateManyWithWhereNestedInput
  >;
}

export interface SceneCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  frames?: Maybe<FrameCreateManyWithoutParentInput>;
  parent: StoryCreateOneWithoutScenesInput;
  position?: Maybe<String>;
}

export interface StoryCreateManyWithoutAuthorInput {
  create?: Maybe<
    StoryCreateWithoutAuthorInput[] | StoryCreateWithoutAuthorInput
  >;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
}

export interface FrameCreateManyWithoutParentInput {
  create?: Maybe<
    FrameCreateWithoutParentInput[] | FrameCreateWithoutParentInput
  >;
  connect?: Maybe<FrameWhereUniqueInput[] | FrameWhereUniqueInput>;
}

export interface SceneUpdateManyDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface FrameCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title: String;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  paragraphs?: Maybe<ParagraphCreateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface SceneUpsertWithWhereUniqueWithoutParentInput {
  where: SceneWhereUniqueInput;
  update: SceneUpdateWithoutParentDataInput;
  create: SceneCreateWithoutParentInput;
}

export interface SceneUpdateInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  frames?: Maybe<FrameUpdateManyWithoutParentInput>;
  parent?: Maybe<StoryUpdateOneRequiredWithoutScenesInput>;
  position?: Maybe<String>;
}

export interface ParagraphCreateManyWithoutParentInput {
  create?: Maybe<
    ParagraphCreateWithoutParentInput[] | ParagraphCreateWithoutParentInput
  >;
  connect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
}

export interface FrameUpdateManyWithoutParentInput {
  create?: Maybe<
    FrameCreateWithoutParentInput[] | FrameCreateWithoutParentInput
  >;
  delete?: Maybe<FrameWhereUniqueInput[] | FrameWhereUniqueInput>;
  connect?: Maybe<FrameWhereUniqueInput[] | FrameWhereUniqueInput>;
  set?: Maybe<FrameWhereUniqueInput[] | FrameWhereUniqueInput>;
  disconnect?: Maybe<FrameWhereUniqueInput[] | FrameWhereUniqueInput>;
  update?: Maybe<
    | FrameUpdateWithWhereUniqueWithoutParentInput[]
    | FrameUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | FrameUpsertWithWhereUniqueWithoutParentInput[]
    | FrameUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<FrameScalarWhereInput[] | FrameScalarWhereInput>;
  updateMany?: Maybe<
    FrameUpdateManyWithWhereNestedInput[] | FrameUpdateManyWithWhereNestedInput
  >;
}

export interface StoryCreateOneWithoutScenesInput {
  create?: Maybe<StoryCreateWithoutScenesInput>;
  connect?: Maybe<StoryWhereUniqueInput>;
}

export interface FrameUpdateWithWhereUniqueWithoutParentInput {
  where: FrameWhereUniqueInput;
  data: FrameUpdateWithoutParentDataInput;
}

export interface FrameUpdateInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  paragraphs?: Maybe<ParagraphUpdateManyWithoutParentInput>;
  parent?: Maybe<SceneUpdateOneRequiredWithoutFramesInput>;
  position?: Maybe<String>;
}

export interface FrameUpdateWithoutParentDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  paragraphs?: Maybe<ParagraphUpdateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface ParagraphWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  parent?: Maybe<FrameWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
  OR?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
  NOT?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
}

export interface FrameUpsertWithWhereUniqueWithoutParentInput {
  where: FrameWhereUniqueInput;
  update: FrameUpdateWithoutParentDataInput;
  create: FrameCreateWithoutParentInput;
}

export interface StoryUpdateWithoutAuthorDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  scenes?: Maybe<SceneUpdateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface FrameScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  styling?: Maybe<String>;
  styling_not?: Maybe<String>;
  styling_in?: Maybe<String[] | String>;
  styling_not_in?: Maybe<String[] | String>;
  styling_lt?: Maybe<String>;
  styling_lte?: Maybe<String>;
  styling_gt?: Maybe<String>;
  styling_gte?: Maybe<String>;
  styling_contains?: Maybe<String>;
  styling_not_contains?: Maybe<String>;
  styling_starts_with?: Maybe<String>;
  styling_not_starts_with?: Maybe<String>;
  styling_ends_with?: Maybe<String>;
  styling_not_ends_with?: Maybe<String>;
  media?: Maybe<String>;
  media_not?: Maybe<String>;
  media_in?: Maybe<String[] | String>;
  media_not_in?: Maybe<String[] | String>;
  media_lt?: Maybe<String>;
  media_lte?: Maybe<String>;
  media_gt?: Maybe<String>;
  media_gte?: Maybe<String>;
  media_contains?: Maybe<String>;
  media_not_contains?: Maybe<String>;
  media_starts_with?: Maybe<String>;
  media_not_starts_with?: Maybe<String>;
  media_ends_with?: Maybe<String>;
  media_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<FrameScalarWhereInput[] | FrameScalarWhereInput>;
  OR?: Maybe<FrameScalarWhereInput[] | FrameScalarWhereInput>;
  NOT?: Maybe<FrameScalarWhereInput[] | FrameScalarWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name: String;
  stories?: Maybe<StoryCreateManyWithoutAuthorInput>;
}

export interface FrameUpdateManyWithWhereNestedInput {
  where: FrameScalarWhereInput;
  data: FrameUpdateManyDataInput;
}

export interface UserCreateOneWithoutStoriesInput {
  create?: Maybe<UserCreateWithoutStoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FrameUpdateManyDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface StoryUpdateManyWithWhereNestedInput {
  where: StoryScalarWhereInput;
  data: StoryUpdateManyDataInput;
}

export interface SceneCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  frames?: Maybe<FrameCreateManyWithoutParentInput>;
  position?: Maybe<String>;
}

export interface SceneCreateManyWithoutParentInput {
  create?: Maybe<
    SceneCreateWithoutParentInput[] | SceneCreateWithoutParentInput
  >;
  connect?: Maybe<SceneWhereUniqueInput[] | SceneWhereUniqueInput>;
}

export interface StoryCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  scenes?: Maybe<SceneCreateManyWithoutParentInput>;
  author: UserCreateOneWithoutStoriesInput;
  position?: Maybe<String>;
}

export interface SceneUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  styling?: Maybe<String>;
  media?: Maybe<String>;
  position?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutAuthorInput>;
}

export interface StorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StoryWhereInput>;
  AND?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
  OR?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
  NOT?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
}

export interface SceneCreateOneWithoutFramesInput {
  create?: Maybe<SceneCreateWithoutFramesInput>;
  connect?: Maybe<SceneWhereUniqueInput>;
}

export interface SceneUpdateManyWithWhereNestedInput {
  where: SceneScalarWhereInput;
  data: SceneUpdateManyDataInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface FrameConnection {
  pageInfo: PageInfo;
  edges: FrameEdge[];
}

export interface FrameConnectionPromise
  extends Promise<FrameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FrameEdge>>() => T;
  aggregate: <T = AggregateFramePromise>() => T;
}

export interface FrameConnectionSubscription
  extends Promise<AsyncIterator<FrameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FrameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFrameSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface StorySubscriptionPayload {
  mutation: MutationType;
  node: Story;
  updatedFields: String[];
  previousValues: StoryPreviousValues;
}

export interface StorySubscriptionPayloadPromise
  extends Promise<StorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StoryPreviousValuesPromise>() => T;
}

export interface StorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StoryPreviousValuesSubscription>() => T;
}

export interface StoryPreviousValues {
  id: ID_Output;
  published: Boolean;
  title?: String;
  styling: String;
  media: String;
  position?: String;
}

export interface StoryPreviousValuesPromise
  extends Promise<StoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  position: () => Promise<String>;
}

export interface StoryPreviousValuesSubscription
  extends Promise<AsyncIterator<StoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  stories: <T = Promise<AsyncIterator<StorySubscription>>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StoryEdge {
  node: Story;
  cursor: String;
}

export interface StoryEdgePromise extends Promise<StoryEdge>, Fragmentable {
  node: <T = StoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StoryEdgeSubscription
  extends Promise<AsyncIterator<StoryEdge>>,
    Fragmentable {
  node: <T = StorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Frame {
  id: ID_Output;
  published: Boolean;
  title: String;
  styling?: String;
  media?: String;
  position?: String;
}

export interface FramePromise extends Promise<Frame>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  paragraphs: <T = FragmentableArray<Paragraph>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = ScenePromise>() => T;
  position: () => Promise<String>;
}

export interface FrameSubscription
  extends Promise<AsyncIterator<Frame>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  paragraphs: <T = Promise<AsyncIterator<ParagraphSubscription>>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = SceneSubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
}

export interface FrameNullablePromise
  extends Promise<Frame | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  paragraphs: <T = FragmentableArray<Paragraph>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = ScenePromise>() => T;
  position: () => Promise<String>;
}

export interface AggregateScene {
  count: Int;
}

export interface AggregateScenePromise
  extends Promise<AggregateScene>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSceneSubscription
  extends Promise<AsyncIterator<AggregateScene>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FrameSubscriptionPayload {
  mutation: MutationType;
  node: Frame;
  updatedFields: String[];
  previousValues: FramePreviousValues;
}

export interface FrameSubscriptionPayloadPromise
  extends Promise<FrameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FramePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FramePreviousValuesPromise>() => T;
}

export interface FrameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FrameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FrameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FramePreviousValuesSubscription>() => T;
}

export interface SceneConnection {
  pageInfo: PageInfo;
  edges: SceneEdge[];
}

export interface SceneConnectionPromise
  extends Promise<SceneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SceneEdge>>() => T;
  aggregate: <T = AggregateScenePromise>() => T;
}

export interface SceneConnectionSubscription
  extends Promise<AsyncIterator<SceneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SceneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSceneSubscription>() => T;
}

export interface FramePreviousValues {
  id: ID_Output;
  published: Boolean;
  title: String;
  styling?: String;
  media?: String;
  position?: String;
}

export interface FramePreviousValuesPromise
  extends Promise<FramePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  position: () => Promise<String>;
}

export interface FramePreviousValuesSubscription
  extends Promise<AsyncIterator<FramePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface ParagraphEdge {
  node: Paragraph;
  cursor: String;
}

export interface ParagraphEdgePromise
  extends Promise<ParagraphEdge>,
    Fragmentable {
  node: <T = ParagraphPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParagraphEdgeSubscription
  extends Promise<AsyncIterator<ParagraphEdge>>,
    Fragmentable {
  node: <T = ParagraphSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Story {
  id: ID_Output;
  published: Boolean;
  title?: String;
  styling: String;
  media: String;
  position?: String;
}

export interface StoryPromise extends Promise<Story>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  scenes: <T = FragmentableArray<Scene>>(args?: {
    where?: SceneWhereInput;
    orderBy?: SceneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  position: () => Promise<String>;
}

export interface StorySubscription
  extends Promise<AsyncIterator<Story>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  scenes: <T = Promise<AsyncIterator<SceneSubscription>>>(args?: {
    where?: SceneWhereInput;
    orderBy?: SceneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
}

export interface StoryNullablePromise
  extends Promise<Story | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  scenes: <T = FragmentableArray<Scene>>(args?: {
    where?: SceneWhereInput;
    orderBy?: SceneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  position: () => Promise<String>;
}

export interface AggregateFrame {
  count: Int;
}

export interface AggregateFramePromise
  extends Promise<AggregateFrame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFrameSubscription
  extends Promise<AsyncIterator<AggregateFrame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParagraphSubscriptionPayload {
  mutation: MutationType;
  node: Paragraph;
  updatedFields: String[];
  previousValues: ParagraphPreviousValues;
}

export interface ParagraphSubscriptionPayloadPromise
  extends Promise<ParagraphSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParagraphPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParagraphPreviousValuesPromise>() => T;
}

export interface ParagraphSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParagraphSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParagraphSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParagraphPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ParagraphPreviousValues {
  id: ID_Output;
  published: Boolean;
  content: String;
  styling?: String;
  media?: String;
  position?: String;
}

export interface ParagraphPreviousValuesPromise
  extends Promise<ParagraphPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  content: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  position: () => Promise<String>;
}

export interface ParagraphPreviousValuesSubscription
  extends Promise<AsyncIterator<ParagraphPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  content: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface StoryConnection {
  pageInfo: PageInfo;
  edges: StoryEdge[];
}

export interface StoryConnectionPromise
  extends Promise<StoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StoryEdge>>() => T;
  aggregate: <T = AggregateStoryPromise>() => T;
}

export interface StoryConnectionSubscription
  extends Promise<AsyncIterator<StoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStorySubscription>() => T;
}

export interface AggregateParagraph {
  count: Int;
}

export interface AggregateParagraphPromise
  extends Promise<AggregateParagraph>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParagraphSubscription
  extends Promise<AsyncIterator<AggregateParagraph>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Paragraph {
  id: ID_Output;
  published: Boolean;
  content: String;
  styling?: String;
  media?: String;
  position?: String;
}

export interface ParagraphPromise extends Promise<Paragraph>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  content: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  parent: <T = FramePromise>() => T;
  position: () => Promise<String>;
}

export interface ParagraphSubscription
  extends Promise<AsyncIterator<Paragraph>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  content: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  parent: <T = FrameSubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
}

export interface ParagraphNullablePromise
  extends Promise<Paragraph | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  content: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  parent: <T = FramePromise>() => T;
  position: () => Promise<String>;
}

export interface ScenePreviousValues {
  id: ID_Output;
  published: Boolean;
  title?: String;
  styling: String;
  media: String;
  position?: String;
}

export interface ScenePreviousValuesPromise
  extends Promise<ScenePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  position: () => Promise<String>;
}

export interface ScenePreviousValuesSubscription
  extends Promise<AsyncIterator<ScenePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface SceneSubscriptionPayload {
  mutation: MutationType;
  node: Scene;
  updatedFields: String[];
  previousValues: ScenePreviousValues;
}

export interface SceneSubscriptionPayloadPromise
  extends Promise<SceneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScenePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScenePreviousValuesPromise>() => T;
}

export interface SceneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SceneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SceneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScenePreviousValuesSubscription>() => T;
}

export interface Scene {
  id: ID_Output;
  published: Boolean;
  title?: String;
  styling: String;
  media: String;
  position?: String;
}

export interface ScenePromise extends Promise<Scene>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  frames: <T = FragmentableArray<Frame>>(args?: {
    where?: FrameWhereInput;
    orderBy?: FrameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = StoryPromise>() => T;
  position: () => Promise<String>;
}

export interface SceneSubscription
  extends Promise<AsyncIterator<Scene>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  styling: () => Promise<AsyncIterator<String>>;
  media: () => Promise<AsyncIterator<String>>;
  frames: <T = Promise<AsyncIterator<FrameSubscription>>>(args?: {
    where?: FrameWhereInput;
    orderBy?: FrameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = StorySubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
}

export interface SceneNullablePromise
  extends Promise<Scene | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  styling: () => Promise<String>;
  media: () => Promise<String>;
  frames: <T = FragmentableArray<Frame>>(args?: {
    where?: FrameWhereInput;
    orderBy?: FrameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = StoryPromise>() => T;
  position: () => Promise<String>;
}

export interface ParagraphConnection {
  pageInfo: PageInfo;
  edges: ParagraphEdge[];
}

export interface ParagraphConnectionPromise
  extends Promise<ParagraphConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParagraphEdge>>() => T;
  aggregate: <T = AggregateParagraphPromise>() => T;
}

export interface ParagraphConnectionSubscription
  extends Promise<AsyncIterator<ParagraphConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParagraphEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParagraphSubscription>() => T;
}

export interface SceneEdge {
  node: Scene;
  cursor: String;
}

export interface SceneEdgePromise extends Promise<SceneEdge>, Fragmentable {
  node: <T = ScenePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SceneEdgeSubscription
  extends Promise<AsyncIterator<SceneEdge>>,
    Fragmentable {
  node: <T = SceneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStory {
  count: Int;
}

export interface AggregateStoryPromise
  extends Promise<AggregateStory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStorySubscription
  extends Promise<AsyncIterator<AggregateStory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FrameEdge {
  node: Frame;
  cursor: String;
}

export interface FrameEdgePromise extends Promise<FrameEdge>, Fragmentable {
  node: <T = FramePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FrameEdgeSubscription
  extends Promise<AsyncIterator<FrameEdge>>,
    Fragmentable {
  node: <T = FrameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Paragraph",
    embedded: false
  },
  {
    name: "Frame",
    embedded: false
  },
  {
    name: "Scene",
    embedded: false
  },
  {
    name: "Story",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
